// Copyright 25-Jun-2024 ÂºDeme
// GNU General Public License - V3 <http://www.gnu.org/licenses/>

/// Approximations (2) model.

import "../model";
import "doc/appr3Doc";

/// Returns a new 'appr2' model.
/// \ -> <model>
mk = \ -> return model.mk(
    "APRX3",
    "Aproximaciones sucesivas (3)",
    appr3Doc.text,
    ["Inicio", "Aprox."],
    [model.percParam, model.percParam],
    refs
  );;

// \[[n.].], [n.] -> [[n.].]
refs = \:arr Closes, :arr Params -> {
  start = Params[0];
  upStart = 1 + start;
  downStart = 1 - start;
  incr = Params[1];
  :arr Cls0 = Closes[0];
  ndates = Closes.size();
  ncos = Cls0.size();

  AllRefs = []; // [[n.].]
  IsSolds = arr.mk(ncos, false);
  Refs = []; // [n.]
  for (cl = Cls0) Refs.push(cl * downStart);

  AllRefs.push(Refs.copy());
  for (idate = 1:ndates) {
    ClosesR = Closes[idate];
    PrvCloses = Closes[idate - 1];

    for (ico = 0:ncos) {
      c = ClosesR[ico];
      prvC = PrvCloses[ico];
      rf = Refs[ico];

      if (IsSolds[ico]) {
        if (c > rf) {
          IsSolds[ico] = false;
          Refs[ico] = c * downStart;
        } else {
          r1 = rf - (rf - c) * incr;
          r2 = c * rf / prvC;
          if (r1 < r2) Refs[ico] = r1;
          else Refs[ico] = r2;
        }
      } else {
        if (c < rf) {
          IsSolds[ico] = true;
          Refs[ico] = c * upStart;
        } else {
          r1 = rf + (c - rf) * incr;
          r2 = c * rf / prvC;
          if (r1 > r2) Refs[ico] = r1;
          else Refs[ico] = r2;
        }
      }
    }
    AllRefs.push(Refs.copy());
  }
  return AllRefs;
};
