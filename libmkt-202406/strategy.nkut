// Copyright 01-Jul-2024 ÂºDeme
// GNU General Public License - V3 <http://www.gnu.org/licenses/>

/// Trading strategy

import "order";
import "model";
import "quotes";
import "stRs";
import "cts";
import "broker";

/// Returns the result of a simulation.
///   md      : Model.
///   qs      : Quotes to perform the simulation.
///   References: Companies references (days x cos).
/// \<model>, <quotes>, [[n.].] -> <stRs>
open = \:model md, :quotes qts, :arr References -> {
  ndates = arr.size(qts.Dates);
  ncos = arr.size(qts.Cos);

  // Global simulation.

  cashV = [cts.initialCapital];
  withdrawalsV = [0];
  Orders = []; // [<order>.]
  Hreals = arr.mk(ndates, 0);
  Haccs = arr.mk(ndates, 0);
  Hrefs = arr.mk(ndates, 0);
  Hwithdrawals = arr.mk(ndates, 0);

  Stocks = arr.mk(ncos, 0);
  Prices = arr.mk(ncos, 0);
  ToDos = arr.mk(ncos, false);
  ToSells = arr.mk(ncos, true);
  DaysTraps = arr.mk(ncos, 0);

  // Profits simulation.

  AllBuys = []; // [[s.]]
  for (i = 0:ncos) AllBuys.push([]);
  AllSales = []; // [[s.]]
  for (i = 0:ncos) AllSales.push([]);
  PrfCashes = arr.mk(ncos, cts.bet);
  PrfStocks = arr.mk(ncos, 0);
  PrfPrices = arr.mk(ncos, 0);
  PrfDaysTraps = arr.mk(ncos, 0);
  Profits = arr.mk(ncos, 0);

  // START -----------------------------

  purchasedV = [0];
  maxToBuyV = [cts.maxCos];
  Hreals[0] = cashV!;
  Haccs[0] = cashV!;
  Hrefs[0] = cashV!;
  for (idate = 1:ndates) {
    dayCashV = [cashV!];
    date = qts.Dates[idate];
    Ops = qts.Opens[idate];
    Cls = qts.Closes[idate];
    Rfs = References[idate - 1];

    maxToBuyV! = cts.maxCos - purchasedV!;
    for (ico = 0:ncos) if (ToDos[ico] & !ToSells[ico] & Stocks[ico] > 0)
      maxToBuyV! += 1;
    realV = [0];
    accV = [0];
    refV = [0];
    for (ico = 0:ncos) {
      nk = qts.Cos[ico];
      :arr Buys = AllBuys[ico];
      :arr Sales = AllSales[ico];
      op = Ops[ico];
      cl = Cls[ico];
      rf = Rfs[ico];

      DaysTraps[ico] -= 1;
      PrfDaysTraps[ico] -= 1;

      if (ToDos[ico]) {
        if (ToSells[ico]) { // there is buy order.
          // Global simulation.
          if (DaysTraps[ico] < 1) {
            if (dayCashV! > cts.minToBet & maxToBuyV! > 0) {
              stocks = math.toInt(cts.bet / op);
              Stocks[ico] = stocks;
              Prices[ico] = op;
              bk = broker.buy(stocks, op);
              cashV! -= bk;
              dayCashV! -= bk;
              Orders.push(order.mk(date, nk, cts.orderBuy, stocks, op));
              purchasedV! += 1;
              maxToBuyV! -= 1;
            }
          }
          // Profits simulation.
          if (PrfDaysTraps[ico] < 1) {
            prfCash = PrfCashes[ico];
            stocksV = [math.toInt((prfCash - broker.buyFees(prfCash)) / op)];
            costV = [broker.buy(stocksV!, op)];
            while (costV! > prfCash) {
              stocksV! -= 1;
              costV! = broker.buy(stocksV!, op);
            }
            PrfStocks[ico] = stocksV!;
            PrfPrices[ico] = op;
            PrfCashes[ico] = prfCash - costV!;
            Buys.push(date);
          }
        } else {
          // Global simulation.
          stocks = Stocks[ico];
          if (stocks > 0) {
            Stocks[ico] = 0;
            cashV! += broker.sell(stocks, op);
            Orders.push(order.mk(date, nk, cts.orderSell, stocks, op));
            purchasedV! -= 1;

            if (op < Prices[ico] * cts.noLossMultiplicator)
              DaysTraps[ico] = cts.daysLoss;
          }
          // Profits simulation.
          pstocks = PrfStocks[ico];
          if (pstocks > 0) {
            PrfStocks[ico] = 0;
            PrfCashes[ico] += broker.sell(pstocks, op);
            Sales.push(date);

            if (op < PrfPrices[ico] * cts.noLossMultiplicator)
              PrfDaysTraps[ico] = cts.daysLoss;
          }
        }
        ToDos[ico] = false;
      }
      stocks = Stocks[ico];
      if (stocks > 0) {
        realV! += broker.sell(stocks, cl);
        accV! += broker.sell(stocks, Prices[ico]);
        refV! += broker.sell(stocks, rf < cl ? rf : cl);
      }

      if (ToSells[ico]) {
        if (rf > cl) {
          ToDos[ico] = true;
          ToSells[ico] = false;
        }
      } else if (rf < cl) {
        ToDos[ico] = true;
        ToSells[ico] = true;
      }
    }

    total = cashV! + realV!;
    if (total > cts.withdrawalLimit & cashV! > cts.minToBet) {
      withdrawalsV! += cts.bet;
      cashV! -= cts.bet;
    }

    Hreals[idate] = cashV! + withdrawalsV! + realV!;
    Haccs[idate] = cashV! + withdrawalsV! + accV!;
    Hrefs[idate] = cashV! + withdrawalsV! + refV!;
    Hwithdrawals[idate] = withdrawalsV!;
  }

  LastCloses = qts.Closes[ndates - 1];
  for (i = 0:ncos) {
    Profits[i] =
      (PrfCashes[i] + PrfStocks[i] * LastCloses[i] - cts.bet) / cts.bet;
  }

  return stRs.mk(
    Orders, Hreals, Haccs, Hrefs, Hwithdrawals, cashV! + withdrawalsV!,
    AllBuys, AllSales, Profits
  );
};

/// Returns the result of a simulation.
/// Returns the the following 'dic'.
///   - sales (n)   : Number of sales.
///   - assets (n)  : cash + withdrawals + portfolio evaluated with closes.
///   - accs (n)    : cash + withdrawals + portfolio evaluated with prices.
///   - rfAssets (n): cash + withdrawals + portfolio evaluated with references.
///   md        : Model.
///   qts       : Quotes to perform the simulation.
///   References: Companies references (days x cos).
/// \<model>, <quotes>, [[n.].] -> {sales: n, assets: n, accs: n, rfAssets: n}
openSimple = \:model md, :quotes qts, :arr References -> {
  ndates = arr.size(qts.Dates);
  ncos = arr.size(qts.Cos);

  // Global simulation.

  cashV = [cts.initialCapital];
  withdrawalsV = [0];
  nsalesV = [0];

  Stocks = arr.mk(ncos, 0);
  Prices = arr.mk(ncos, 0);
  ToDos = arr.mk(ncos, false);
  ToSells = arr.mk(ncos, true);
  DaysTraps = arr.mk(ncos, 0);

  // START -----------------------------

  purchasedV = [0];
  for (idate = 1:ndates) {
    dayCashV = [cashV!];
    Ops = qts.Opens[idate];
    Cls = qts.Closes[idate];
    Rfs = References[idate - 1];

    assetsV = [0];
    for (ico = 0:ncos) {
      op = Ops[ico];
      cl = Cls[ico];
      rf = Rfs[ico];

      DaysTraps[ico] -= 1;

      if (ToDos[ico]) {
        if (ToSells[ico]) { // there is buy order.
          // Global simulation.
          if (DaysTraps[ico] < 1) {
            if (dayCashV! > cts.minToBet & purchasedV! < cts.maxCos) {
              stocks = math.toInt(cts.bet / op);
              Stocks[ico] = stocks;
              Prices[ico] = op;
              bk = broker.buy(stocks, op);
              cashV! -= bk;
              dayCashV! -= bk;
              purchasedV! += 1;
            }
          }
        } else {
          // Global simulation.
          stocks = Stocks[ico];
          if (stocks > 0) {
            Stocks[ico] = 0;
            cashV! += broker.sell(stocks, op);
            nsalesV! += 1;
            purchasedV! -= 1;

            if (op < Prices[ico] * cts.noLossMultiplicator)
              DaysTraps[ico] = cts.daysLoss;
          }
        }
        ToDos[ico] = false;
      }
      stocks = Stocks[ico];
      if (stocks > 0) assetsV! += broker.sell(stocks, cl);

      if (ToSells[ico]) {
        if (rf > cl) {
          ToDos[ico] = true;
          ToSells[ico] = false;
        }
      } else if (rf < cl) {
        ToDos[ico] = true;
        ToSells[ico] = true;
      }
    }

    total =cashV! + assetsV!;
    if (total > cts.withdrawalLimit & cashV! > cts.minToBet) {
      withdrawalsV! += cts.bet;
      cashV! -= cts.bet;
    }
  }

  // Global simulation.
  cashV! += withdrawalsV!;
  assetsV = [cashV!];
  accsV = [cashV!];
  rfAssetsV = [cashV!];
  LastCls = qts.Closes[ndates - 1];
  LastRfs = References[ndates - 1];
  for (i = 0:ncos) {
    stk = Stocks[i];
    cl = LastCls[i];
    rf = LastRfs[i];
    if (stk > 0) {
      assetsV! += broker.sell(stk, cl);
      accsV! += broker.sell(stk, Prices[i]);
      rfAssetsV! += broker.sell(stk, rf < cl ? rf : cl);
    }
  }

  return {
      sales: nsalesV!, assets: assetsV!, accs: accsV!, rfAssets: rfAssetsV!
  };
};

/// Returns the the following 'dic'.
///   - sales (n)    : Number of sales.
///   - assets (n)   : cash + withdrawals + portfolio evaluated with closes.
///   - accs (n)     : cash + withdrawals + portfolio evaluated with prices.
///   - refAssets (n): cash + withdrawals + portfolio evaluated with references.
///   - profits (n)  : Profits ratio average. Portfolio evaluated with closes.
///   - rfProfits (n): Profits ratio average. Portfolio evaluated with references.
///   md        : Model.
///   qts       : Quotes to perform the simulation.
///   References: Companies references (days x cos).
/// \<model>, <quotes>, [[n.].] ->
///   {sales: n, assets: n, accs: n, rfAssets: n, profits: n, rfProfits: n}
openSimple2 = \:model md, :quotes qts, References -> {
  ndates = arr.size(qts.Dates);
  ncos = arr.size(qts.Cos);

  // Global simulation.

  cashV = [cts.initialCapital];
  withdrawalsV = [0];
  nsalesV = [0];

  Stocks = arr.mk(ncos, 0);
  Prices = arr.mk(ncos, 0);
  ToDos = arr.mk(ncos, false);
  ToSells = arr.mk(ncos, true);
  DaysTraps = arr.mk(ncos, 0);

  // Profits simulation.

  PrfCashes = arr.mk(ncos, cts.bet);
  PrfStocks = arr.mk(ncos, 0);
  PrfPrices = arr.mk(ncos, 0);
  PrfDaysTraps = arr.mk(ncos, 0);

  // START -----------------------------

  purchasedV = [0];
  for (idate = 1:ndates) {
    dayCashV = [cashV!];
    Ops = qts.Opens[idate];
    Cls = qts.Closes[idate];
    Rfs = References[idate - 1];

    assetsV = [0];
    for (ico = 0:ncos) {
      op = Ops[ico];
      cl = Cls[ico];
      rf = Rfs[ico];

      DaysTraps[ico] -= 1;
      PrfDaysTraps[ico] -= 1;

      if (ToDos[ico]) {
        if (ToSells[ico]) { // there is buy order.
          // Global simulation.
          if (DaysTraps[ico] < 1) {
            if (dayCashV! > cts.minToBet & purchasedV! < cts.maxCos) {
              stocks = math.toInt(cts.bet / op);
              Stocks[ico] = stocks;
              Prices[ico] = op;
              bk = broker.buy(stocks, op);
              cashV! -= bk;
              dayCashV! -= bk;
              purchasedV! += 1;
            }
          }
          // Profits simulation.
          if (PrfDaysTraps[ico] < 1) {
            prfCash = PrfCashes[ico];
            stocksV = [math.toInt((prfCash - broker.buyFees(prfCash)) / op)];
            costV = [broker.buy(stocksV!, op)];
            while (costV! > prfCash) {
              stocksV! -= 1;
              costV! = broker.buy(stocksV!, op);
            }
            PrfStocks[ico] = stocksV!;
            PrfPrices[ico] = op;
            PrfCashes[ico] = prfCash - costV!;
          }
        } else {
          // Global simulation.
          stocks = Stocks[ico];
          if (stocks > 0) {
            Stocks[ico] = 0;
            cashV! += broker.sell(stocks, op);
            nsalesV! += 1;
            purchasedV! -= 1;

            if (op < Prices[ico] * cts.noLossMultiplicator)
              DaysTraps[ico] = cts.daysLoss;
          }
          // Profits simulation.
          pstocks = PrfStocks[ico];
          if (pstocks > 0) {
            PrfStocks[ico] = 0;
            PrfCashes[ico] += broker.sell(pstocks, op);

            if (op < PrfPrices[ico] * cts.noLossMultiplicator)
              PrfDaysTraps[ico] = cts.daysLoss;
          }
        }
        ToDos[ico] = false;
      }
      stocks = Stocks[ico];
      if (stocks > 0) assetsV! += broker.sell(stocks, cl);

      if (ToSells[ico]) {
        if (rf > cl) {
          ToDos[ico] = true;
          ToSells[ico] = false;
        }
      } else if (rf < cl) {
        ToDos[ico] = true;
        ToSells[ico] = true;
      }
    }

    total = cashV! + assetsV!;
    if (total > cts.withdrawalLimit & cashV! > cts.minToBet) {
      withdrawalsV! += cts.bet;
      cashV! -= cts.bet;
    }
  }

  // Global simulation.
  cashV! += withdrawalsV!;
  assetsV = [cashV!];
  accsV = [cashV!];
  rfAssetsV = [cashV!];
  LastCls = qts.Closes[ndates - 1];
  LastRfs = References[ndates - 1];
  for (i = 0:ncos) {
    stk = Stocks[i];
    cl = LastCls[i];
    rf = LastRfs[i];
    if (stk > 0) {
      assetsV! += broker.sell(stk, cl);
      accsV! += broker.sell(stk, Prices[i]);
      rfAssetsV! += broker.sell(stk, rf < cl ? rf : cl);
    }
  }

  // Profits simulation.
  profitsV = [0];
  rfProfitsV = [0];
  for (i = 0:ncos) {
    prfCash = PrfCashes[i];
    stk = PrfStocks[i];
    cl = LastCls[i];
    rf = LastRfs[i];
    profitsV! += (prfCash + (stk > 0 ? stk * cl : 0) - cts.bet) / cts.bet;
    rfProfitsV! += (
      prfCash + (
        stk > 0
        ? stk * (rf < cl ? rf : cl)
        : 0
      ) - cts.bet) / cts.bet
    ;
  }

  return {
      sales: nsalesV!, assets: assetsV!, accs: accsV!, rfAssets: rfAssetsV!,
      profits: profitsV! / ncos, rfProfits: rfProfitsV! / ncos
  };
};

/// Returns the result of a simulation.
/// Returns the the following 'dic'.
///   - Sales ([n.])   : Number of sales.
///                      One entry for each Parameter in the same order.
///   - Assets ([n.])  : cash + withdrawals + portfolio evaluated with closes.
///                      One entry for each Parameter in the same order.
///   - Accs ([n.])     : cash + withdrawals + portfolio evaluated with prices.
///                      One entry for each Parameter in the same order.
///   - RfAssets ([n.]): cash + withdrawals + portfolio evaluated with references.
///                      One entry for each Parameter in the same order.
///   md      : Model.
///   qs      : Quotes to perform the simulation.
///   Params  : Array of model parameters.
/// \<model>, <quotes>, [[n.].] ->
///   {Sales: [n.], Assets: [n.], Accs: [n.], RfAssets: [n.]}
stGroup = \:model md, :quotes qts, :arr Params -> {
  n = Params.size();
  Sales = arr.mk(n, 0);
  Assets = arr.mk(n, 0);
  Accs = arr.mk(n, 0);
  RfAssets = arr.mk(n, 0);

  for (i = 0:n) {
    References = md.refs(qts.Closes, Params[i]);
    Rs = openSimple(md, qts, References);
    Sales[i] = Rs.sales;
    Assets[i] = Rs.assets;
    Accs[i] = Rs.accs;
    RfAssets[i] = Rs.rfAssets;
  }
  return {Sales, Assets, Accs, RfAssets};
};

/// Returns the result of a simulation.
/// Returns the the following 'dic'.
///   - Sales ([n.])    : Number of sales.
///                       One entry for each Parameter in the same order.
///   - Assets ([n.])   : cash + withdrawals + portfolio evaluated with closes.
///                       One entry for each Parameter in the same order.
///   - Accs ([n.])     : cash + withdrawals + portfolio evaluated with prices.
///                      One entry for each Parameter in the same order.
///   - RfAssets ([n.]) : cash + withdrawals + portfolio evaluated with references.
///                       One entry for each Parameter in the same order.
///   - Profits ([n.])  : Profits ratio average. Portfolio evaluated with Closes.
///                       One entry for each Parameter in the same order.
///   - RfProfits ([n.]): Profits ratio average. Portfolio evaluated with references.
///                       One entry for each Parameter in the same order.
///   md      : Model.
///   qs      : Quotes to perform the simulation.
///   Params  : Array of model parameters.
/// \<model>, <quotes>, [[n.].] ->
///   { Sales: [n.], Assets: [n.], Accs: [n.], RfAssets: [n.],
///-    Profits: [n.], RfProfits: [n.]}
stGroup2 = \:model md, :quotes qts, :arr Params -> {
  n = Params.size();
  Sales = arr.mk(n, 0);
  Assets = arr.mk(n, 0);
  Accs = arr.mk(n, 0);
  RfAssets = arr.mk(n, 0);
  Profits = arr.mk(n, 0);
  RfProfits = arr.mk(n, 0);

  for (i = 0:n) {
    References = md.refs(qts.Closes, Params[i]);
    Rs = openSimple2(md, qts, References);
    Sales[i] = Rs.sales;
    Assets[i] = Rs.assets;
    Accs[i] = Rs.accs;
    RfAssets[i] = Rs.rfAssets;
    Profits[i] = Rs.profits;
    RfProfits[i] = Rs.rfProfits;
  }
  return {Sales, Assets, Accs, RfAssets, Profits, RfProfits};
};

